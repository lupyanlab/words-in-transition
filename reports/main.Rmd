---
title: "The emergence of lexical categories from iterated vocal imitation"
author: "Pierce Edmiston"
output:
  html_document:
    theme: flatly
    toc: true
---

```{r, config, echo = FALSE}
library(knitr)
library(printr)

opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  cache.path = ".cache/",
  fig.path = "figs/",
  fig.width = 8
)

read_chunk("4-collect-transcriptions/results.R")
read_chunk("5-transcription-matches/results.R")
```

```{r setup}
library(dplyr)
library(magrittr)
library(stringr)
library(ggplot2)
library(scales)
library(lme4)
library(broom)
library(AICcmodavg)

library(wordsintransition)
data("transcription_matches")

transcription_matches %<>%
  recode_question_type %>%
  recode_message_type %>%
  recode_version
```

# Determining the sounds to imitate

We started with 6 sounds in each of 6 categories and reduced that number to 4 sounds in each of 4 categories through two "odd one out" norming experiments.

# Collecting iterated imitations

## Methods

```{r telephone-game, engine = "dot"}
digraph {
  node[fontname="helvetica", fontsize=30];

  glass -> {glass1, glass2, glass3, glass4};
  tear -> {tear1, tear2, tear3, tear4};
  water -> {water1, water2, water3, water4};
  zipper -> {zipper1, zipper2, zipper3, zipper4};
  
  glass[shape="none"];
  tear[shape="none"];
  water[shape="none"];
  zipper[shape="none"];

  glass1[label="seed 1"];
  glass2[label="2"];
  glass3[label="3"];
  glass4[label="4"];

  tear1[label="1"];
  tear2[label="2"];
  tear3[label="3"];
  tear4[label="4"];

  water1[label="1"];
  water2[label="2"];
  water3[label="3"];
  water4[label="4"];

  zipper1[label="1"];
  zipper2[label="2"];
  zipper3[label="3"];
  zipper4[label="4"];

  glass1 -> {subj1, subj2, subj3, subj4};

  subj1[label="branch 1\ngen 1"];
  subj2[label="2"];
  subj3[label="3"];
  subj4[label="4"];
  
  gen2[label="2"];
  gen3[label="3"];
  gen4[label="4"];
  gen5[label="5"];
  gen6[label="6"];
  gen7[label="7"];
  gen8[label="branch 1\ngen 8"];
  
  subj1 -> gen2 -> gen3 -> gen4 -> gen5 -> gen6 -> gen7 -> gen8;
  
}
```

# Matching imitations to original sounds

## Methods

Each imitation is matched in three different "guess the seed" conditions:

1. Category match (true seed)
2. Category match
3. Specific match

```{r category-match-true-seed, engine = "dot"}
digraph {
  labelloc="t";
  label="Category match (true seed)";

  graph[fontname="helvetica", fontsize=30];
  node[fontname="helvetica", fontsize=30];
  
  glass[shape="none"];
  tear[shape="none"];
  water[shape="none"];
  zipper[shape="none"];

  glass -> {glass1, glass2, glass3, glass4};
  tear -> {tear1, tear2, tear3, tear4};
  water -> {water1, water2, water3, water4};
  zipper -> {zipper1, zipper2, zipper3, zipper4};

  glass1[style="filled", fillcolor="#66C2A5"];
  tear2[style="filled", fillcolor="#66C2A5"];
  water3[style="filled", fillcolor="#66C2A5"];
  zipper4[style="filled", fillcolor="#66C2A5"];

  glass1[label="1"];
  glass2[label="2"];
  glass3[label="3"];
  glass4[label="4"];

  tear1[label="1"];
  tear2[label="2"];
  tear3[label="3"];
  tear4[label="4"];

  water1[label="1"];
  water2[label="2"];
  water3[label="3"];
  water4[label="4"];

  zipper1[label="1"];
  zipper2[label="2"];
  zipper3[label="3"];
  zipper4[label="4"];

  tear2 -> gen1;
  gen1[label="?", style="filled", fillcolor="#FC8D62"];
}
```

```{r category-match, engine = "dot"}
digraph {
  labelloc="t";
  label="Category match";

  graph[fontname="helvetica", fontsize=30];
  node[fontname="helvetica", fontsize=30];
  
  glass[shape="none"];
  tear[shape="none"];
  water[shape="none"];
  zipper[shape="none"];

  glass -> {glass1, glass2, glass3, glass4};
  tear -> {tear1, tear2, tear3, tear4};
  water -> {water1, water2, water3, water4};
  zipper -> {zipper1, zipper2, zipper3, zipper4};

  glass1[style="filled", fillcolor="#66C2A5"];
  tear3[style="filled", fillcolor="#66C2A5"];
  water3[style="filled", fillcolor="#66C2A5"];
  zipper4[style="filled", fillcolor="#66C2A5"];

  glass1[label="1"];
  glass2[label="2"];
  glass3[label="3"];
  glass4[label="4"];

  tear1[label="1"];
  tear2[label="2"];
  tear3[label="3"];
  tear4[label="4"];

  water1[label="1"];
  water2[label="2"];
  water3[label="3"];
  water4[label="4"];

  zipper1[label="1"];
  zipper2[label="2"];
  zipper3[label="3"];
  zipper4[label="4"];

  tear2 -> gen1;
  gen1[label="?", style="filled", fillcolor="#FC8D62"];
}
```

```{r specific-match, engine = "dot"}
digraph {
  labelloc="t";
  label="Specific match";

  graph[fontname="helvetica", fontsize=30];
  node[fontname="helvetica", fontsize=30];
  
  glass[shape="none"];
  tear[shape="none"];
  water[shape="none"];
  zipper[shape="none"];

  glass -> {glass1, glass2, glass3, glass4};
  tear -> {tear1, tear2, tear3, tear4};
  water -> {water1, water2, water3, water4};
  zipper -> {zipper1, zipper2, zipper3, zipper4};

  tear1[style="filled", fillcolor="#66C2A5"];
  tear2[style="filled", fillcolor="#66C2A5"];
  tear3[style="filled", fillcolor="#66C2A5"];
  tear4[style="filled", fillcolor="#66C2A5"];

  glass1[label="1"];
  glass2[label="2"];
  glass3[label="3"];
  glass4[label="4"];

  tear1[label="1"];
  tear2[label="2"];
  tear3[label="3"];
  tear4[label="4"];

  water1[label="1"];
  water2[label="2"];
  water3[label="3"];
  water4[label="4"];

  zipper1[label="1"];
  zipper2[label="2"];
  zipper3[label="3"];
  zipper4[label="4"];

  tear2 -> gen1;
  gen1[label="?", style="filled", fillcolor="#FC8D62"];
}
```

# Collecting transcriptions of sounds

```{r 4-setup}
```

## Methods

### Selected sounds

Transcribed sounds include all 16 seed sound effects and all imitatations in the last generation of each iteration chain.

```{r 4-num-sounds-transcribed}
```

### Number of transcriptions for each sound

```{r 4-num-transcriptions-per-imitation, fig.width = 14}
```

## Results

There was less agreement among transcribers for the seed sound effects
than there was among the transcribers of n-th generation imitations.

```{r 4-transcription-agreement}
```

# Matching transcriptions to original sounds

```{r 5-setup}
```

## Methods

### Selected transcriptions

We obtained match-to-seed accuracy ratings for the 4 most frequent spellings
of a sample of 8 transcribed sounds.

### Subjects

```{r, 5-subjects}
transcription_matches %>%
  group_by(version) %>%
  summarize(
    num_subjects = length(unique(subj_id)),
    num_responses_per_subject = round(n()/num_subjects)
  ) %>%
  kable(col.names = c("Version", "Subjects", "Responses per subject"),
        align = "l")
```

Subjects were excluded if they failed the catch trial, which indicated
that they should select the third option.

```{r, 5-catch-trials, fig.width = 4}
```

## Results

```{r, 5-plot-template}
```

```{r, 5-plot-means}
```

```{r, 5-model, echo = 1, cache = TRUE}
```

```{r, 5-model-preds}
```

### Agreement as a predictor of matching accuracy

Do the imitations where there is a lot of agreement in the transcriptions have higher matching accuracy?